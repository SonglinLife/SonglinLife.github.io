<!-- build time:Wed Jun 08 2022 16:26:20 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Life" href="https://songlinlife.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="Life" href="https://songlinlife.top/atom.xml"><link rel="alternate" type="application/json" title="Life" href="https://songlinlife.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="MIT6.824"><link rel="canonical" href="https://songlinlife.top/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab2-Raft/"><title>MIT6.824: lab2 Raft - 分布式 | Songlin = Life</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">MIT6.824: lab2 Raft</h1><div class="meta"><span class="item" title="创建时间：2022-02-26 11:38:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-26T11:38:28+08:00">2022-02-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Songlin</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="item" rel="index" title="分类于 分布式"><span itemprop="name">分布式</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://songlinlife.top/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab2-Raft/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Kalice"><meta itemprop="description" content=", Life is not about lifestyle, it means Lithium and Ferrum."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Life"></span><div class="body md" itemprop="articleBody"><p>首先我是读了论文之后再写这个 lab 的，但 raft 论文的内容太多了，只能慢慢一点点看。现在还是先把 lab 完成。</p><p>强烈安利：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbFViVkJWenZOVnhoZ2JjSFFCYmtrUQ==">https://mp.weixin.qq.com/s/lUbVBVzvNVxhgbcHQBbkkQ</span></p><p>先上图</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220305162951465.png" alt="image-20220305162951465"></p><p>4 个小题全部通关，并且并行测试 1000 次无出错。</p><h3 id="part-2a"><a class="anchor" href="#part-2a">#</a> Part 2A</h3><p><strong>任务要求</strong>：实现选举算法和心跳包。如果旧的 leader 没有问题就让旧的 leader 继续执行，如果旧的 leader 有问题那么就选举新的 leader。</p><p>这意味着我们不用设置 normal term，只要考虑 leader fail 这种情况。</p><p><strong>任务提示</strong>：</p><ul><li>完成 <code>raft.go</code></li><li>完成 <code>RequestVote</code> RPC</li><li>实现 <code>AppendEntries</code> RPC</li><li>注意不要发生同时进行选举的情况。</li><li>要求 leader 发生心跳包每秒不超过 10 次。</li><li>要求旧的 leader fail 5 秒内完成选举。</li><li>因为 tester 旅程每秒只能发送 10 次心跳，所以 election timeout 必须要大于 paper 里描述的 150-300。</li></ul><h3 id="part2b"><a class="anchor" href="#part2b">#</a> Part2B</h3><h4 id="33更新"><a class="anchor" href="#33更新">#</a> 3.3 更新</h4><p>我真的想干死他妈了，折腾了好几天终于无伤打过 LAB2B，运行 100 次也没有出错，这里面的坑点真的很多。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220303115450291.png" alt="image-20220303115450291"></p><p>首先需要明确 committed 是如何被确认的：</p><p>对于 leader 来说：<strong>nextIndex -&gt; matchIndex -&gt; commitIndex -&gt; applyIndex</strong></p><blockquote><p>If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N</p></blockquote><p>刚开始我也搞不懂这个 <code>matchIndex</code> 是什么东西，leader 是通过 check majority matchIndex 并且如果该 log entry 属于当前 term 就确认 committed。</p><p>对于 follower: **preLogIndex -(匹配成功)&gt; len (logs) -compart with leadercommitted&gt; commitIndex -&gt; applyIndex **</p><p><strong>commitIndex = min(len(logs) , leaderCommitted</strong></p><p>对于 follower 来说可以是 leader 告知 committed，也可以是通过 append log 后自己确认，总之这个过程逻辑自洽。</p><p>但是这个有一个很严重的坑点，会导致时不时出现 <strong>index out of range</strong> 这个错误。这个错误其实有在 raft guide 上写明，但是我当时并没有看懂，导致执行 100 次总有几次报这个 out of range 错误。。。。</p><p>出现这个问题的原因就是 follower 应用了 stale AppendEntries PRC，然后给 leader 发送了 reply success = true。因为 leader 会重复发送 AppendEntries PRC，如果某个 AppendEntries PRC 返回 true 后，leader 就会执行：<strong>nextIndex[server] += len(args.entries)</strong>，这就导致有时候 leader 会将相同的 AppendEntries PRC 应用两次后，nextIndex [server] += len (args.entries) 也执行两次。最后导致 nextIndex [server] 要超过了 log 的长度。</p><p>解决方法：</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>last <span class="token operator">:=</span> rf<span class="token punctuation">.</span>logs<span class="token punctuation">[</span>args<span class="token punctuation">.</span>PrevLogIndex<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 难点在于如何判断旧的 rpc</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>Entries<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">&#123;</span> <span class="token comment">// 判断要 append 的 log entries 是不是已经 append 上了</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    flag <span class="token operator">:=</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> last<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>TermNumber <span class="token operator">!=</span> args<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>TermNumber <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            flag <span class="token operator">=</span> <span class="token boolean">false</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">break</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> flag <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        reply<span class="token punctuation">.</span>XTerm <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span> <span class="token comment">// 表示这个是过时的 rpc</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>还有一个很严重的坑点，就是选举超时重置，它会导致<strong> rejoin of partitioned leader <em>...</em></strong> 这个测试时不时失败，这是因为选举不当，导致 cluster 没有及时选举出 leader。</p><p>这里需要注意，什么时候才会重置 election timeout：</p><ul><li>当 follower 升级为 candidate 时会重置。</li><li>当 follower 投出自己的一票时会重置。</li><li>当 follower 接受到 leader 的 appendEntries PRC 时会重置。</li></ul><p>第一种情况很简单，就是因为超时才会升级为 candidate，所以成为 candidate 后必须重置。</p><p>第二情况有些复杂，如果一个 leader 或者 candidate 接受到一个 vote request，其中 rf.currentTerm &lt; args.Term。这说明该 leader 或者 candidate 已经 out of date，必须强制转换为 follower，注意，强制转换为 follower 并不代表它可以重置它自身的 election timeout。只有满足严格选举要求，把自己的票投出去后才可以重置。follower 在每一个 Term 有且只有一张选票！但 server 进行 term 提升后就可以分配一张新选票。</p><p>第三种情况其实和第二种情况类似，appendEntries PRC 只能由 leader 发出，一旦当前 server 确认其自身的 currentTerm &lt;= args.Term 就会把选举时间重置。</p><p>只要注意这两个问题：旧 AppendEntries 和 election timeout，就可以轻松 pass all test 了！</p><h3 id="part-2c"><a class="anchor" href="#part-2c">#</a> Part 2C</h3><p>这个 lab 要求我们实现 persistence。</p><h4 id="33更新-2"><a class="anchor" href="#33更新-2">#</a> 3.3 更新</h4><p>无伤通关，就很 nice！</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220303191029815.png" alt="image-20220303191029815"></p><p>执行超过 100 次，仍然这么坚挺！太佩服我自己了，嘿嘿😄</p><p>这个基本思路很简单，就是实现 <code>persist</code> ，然后把 <code>persist()</code> 插入到 persist state 变换的地方，通过 figure 2 不难知道：</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220303172723928.png" alt="image-20220303172723928"></p><p>只要这三个变量改变的时候，我们就插入 <code>persist</code> 。</p><p>但是这里也有一个坑点，这就 appendEntries RPC 会因为网络出错，下面我来描述一下出错情境：</p><p>首先明确，因为我们会不断重复发 AppendEntries RPC，这就导致 follower 需要检查，这个 AppendEntries RPC 是否已经过时，如果过时就返回 false，如果没过时就返回 true</p><h5 id="testfigure8unreliable2c报错返回true的appendentriesrpc丢失问题"><a class="anchor" href="#testfigure8unreliable2c报错返回true的appendentriesrpc丢失问题">#</a> TestFigure8Unreliable2C 报错，返回 true 的 AppendEntriesRPC 丢失问题</h5><p>原因在于，leader 首先发送了一份 entries，follower 通过 AppendEntries 收到了这份 Entries。follower 检查到这个 AppendEntries 中携带的 Entries 没有被 Append 到自己的 logs 中，于是它 append，并返回 true。但是这个本该返回 true 的 AppendEntries RPC 因为网络没有返回（永久丢失，或者返回很慢，leader 超时不再接受），leader 于是又重新发送了一份相同的 Entries。follower 检查到这个 AppendEntries 中携带的 Entries 之前已经 Append 过了，于是它返回给 leader false。leader 收到 false 后于是重复发送，于是整个系统陷入了 <code>living lock</code> 。</p><p><strong>解决办法</strong>：当 follower 检测到 stale AppendEntriesRPC 时，它告诉 leader，这个 RPC 过时了，并且同时返回 follower 自己的 <code>len(logs)</code> 也就是 <code>XIndex</code> 。leader 检查到过时的 RPC，它通过检查 <code>reply.XIndex == len(args.Entris) + rf.nextIndex[server]</code> ，如果满足说明它没有接受到那个返回 true 的 AppendEntries，于是它将 <code>rf.nextIndex[server] = reply.Xindex</code> 。至此，我们就能够解决返回 true 的 AppendEntriesRPC 丢失问题。</p><h5 id="unreliable-churn-out-of-range-问题"><a class="anchor" href="#unreliable-churn-out-of-range-问题">#</a> unreliable churn out of range 问题</h5><p>原因在于，网络太混乱了。在上面我们提到，返回 true 的 AppendEntriesRPC 会因为网络丢失，然后 leader 一直陷入活锁。我们的解决办法是告诉 leader，这个 AppendEntries 过时了，leader 来检查需不需要修改 <code>rf.nextIndex</code> 。</p><p>但是！！！</p><p>你有没有想过，因为网络很乱，如果 stale appendEntriesRPC 要比那个返回 true 的 AppendEntriesRPC 先返回呢？leader 对于 stale AppendEntriesRPC，它会认为自己之前的那个返回 True 的 AppendEntriesRPC 丢失了。于是 leader 修改了自己的 nextIndex。但是那个返回 true 的 AppendEntries 因为网络还可以，最后还是成功返回了。leader 于是又修改了自己的 <code>nextIndex</code> 。这就导致了 out of range 的出现，并且这个问题是偶发性的，因为这属于网络中的极端情况。</p><p>我们的解决办法也很简单，如果 leader 要修改自己的 nextIndex，必须满足：</p><p><code>reply.XIndex == len(args.Entries) + rf.nextIndex[server]</code></p><h5 id="testfigure8unreliable2c稀有out-of-range"><a class="anchor" href="#testfigure8unreliable2c稀有out-of-range">#</a> TestFigure8Unreliable2C 稀有 out of range</h5><p>因为我的 log 日志的 index 是从 1 开始的，于是在初始化时候，我会默认将 index = 0 设置为 0， applyindex =0 , commitIndex= 0。</p><p>但是在设置 nextIndex，因为日志不匹配，我就需要遍历找到最优的 Index，但是这里我的遍历条件是：</p><p><code>for i = len(rf.logs) - 1; i &gt;= 0; i--</code></p><p>这就会导致在很罕见的情况下，i 会被归为 0，而我们用 0 给 nextIndex 赋值，就导致 preLogIndex 变成了 - 1。这就会出现 out of range。但这个情况很少见，100 次里能出现 1 次？</p><p>改成： <code>for i = len(rf.logs) - 1; i &gt;= 1; i--</code> 就行了。</p><p><strong>都是细节！真的太细了。。。。</strong></p><h3 id="part2d"><a class="anchor" href="#part2d">#</a> Part2D</h3><p>这个 lab 要求我们完成 log compaction。</p><p>需要实现 <code>Snapshot(index int, snapshot []byte)</code> ，tester 来定期调用。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220303200330913.png" alt="image-20220303200330913"></p><h4 id="无伤通关34更新"><a class="anchor" href="#无伤通关34更新">#</a> 无伤通关！！！！！（3.4 更新）</h4><p>终于无伤通关了 lab2 了，真的服了我自己了。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220304214412025.png" alt="image-20220304214412025"></p><p>批量测试还在跑，但是问题不大，嘿嘿。</p><p>2D 其实很简单，就是需要将原来的索引进行替换，我的选择是写两个转换函数：</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">Convert</span><span class="token punctuation">(</span>index <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">return</span> index <span class="token operator">-</span> rf<span class="token punctuation">.</span>lastIncludedIndex</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">Reconvert</span><span class="token punctuation">(</span>index <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">return</span> index <span class="token operator">+</span> rf<span class="token punctuation">.</span>lastIncludedIndex</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在刚开始我的想法是，因为每一次做 snap 都会切断 logs，于是需要考虑处理空 log 日志的情况，但是其实没有必要，如果考虑空 log 会导致整个代码逻辑变得非常复杂。</p><p>解决方法：每一次做 snapshot 得到新的 log 时候，我们在 logs 前面插入一个空 log entry，并且它的 term 等于 <code>lastIncludeTerm</code> 。于是我们之前写的代码就只要一点点改变。</p><p>第二个坑点就是，选择什么时候调用 Installsnapshot。我最开始想的是在 sendAppendEntries 在这个函数的返回逻辑部分进行处理，但是由于 RPC 是建立在 UDP 上的，整个网络异常混乱，导致可能多个 Installsnapshot 调用之间顺序很乱，不利于我们的思考。</p><p>解决办法：把调用 Installsnapshot 放到 heartbeat 函数里，让每一次 heartbeat 考虑要不要调用 installsnapshot。</p><h4 id="installsnapshot-rpc"><a class="anchor" href="#installsnapshot-rpc">#</a> Installsnapshot RPC</h4><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220304215521240.png" alt="image-20220304215521240"></p><p>按照要求实现这个 RPC 就行了，需要注意因为整个网络不可信，我们需要验证这个 InstallSnapshot 是否已经过时。</p><h3 id="遗留的问题"><a class="anchor" href="#遗留的问题">#</a> 遗留的问题</h3><p>这是我做这个 lab 发现的一个很奇妙的现象，但我完成了 2D 的时候，回过头我检查之前的 ABC 测试，发现 B 测试中的 *😗 RPC byte count 测试出现 RPC byte count failed。</p><p>这个问题是因为，整个网络是 UDP 的，会出现这么一种情况：RPC 包发出去后，因为 UDP 广播，被自己立即接受了，并返回。这样就使得整个网络变得异常臃肿。</p><p>这个 Bug 出现的原因是因为，我在代码中增加了这样一个逻辑，一旦检查到自己发出的 RPC 包被自己接收后就 return。</p><p>但是我至今也没搞懂，为什么不行！</p><p>这个问题，未来的我，你可以解决的对吧？😏</p><h3 id="raft-basic"><a class="anchor" href="#raft-basic">#</a> Raft Basic</h3><p>将 servers 分为三种状态：leader、follower 和 candidate。</p><p>follower 是消极的，他们只能响应 leader 或者 candidate 的请求。candidate 是选举时产生的。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226123046018.png" alt="image-20220226123046018"></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226123113136.png" alt="image-20220226123113136"></p><p>就像图中描述的，term 分为两个阶段 election 和 normal。每个 term 都有对于的 current term number。<strong>如果 candidate 或者 leader 发现他的 term 过时了，那么他们会自动变为 follows。</strong></p><p>RequestVote RPCs 在选举时由 candidate 进行初始化，并且 AppendEntries RPCs 被 leader 初始化用于复制 log entries 和提供 heartbeat（就是空的 AppendEntries）。</p><p><strong>记住 raft 中的节点其实就是状态机！</strong></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220228220844868.png" alt="image-20220228220844868"></p><p>这里我有一个想法，因为是 state machine，由于 raft 层记录了 lastApply，而且 state machine 只能 apply committed entries。所有的机子都会 apply 相同的 committed entries。因此这里可能会出现重复响应情况，比如 client 发送请求给 leader，leader committed 请求后返回给 client 响应之后马上挂掉了，raft 通过选举产生了新的 leader，那么新的 leader 可能会让 state machine 重复 apply，也就是重复发送响应。</p><p><strong>但是这没有问题！重复是 tcp 层应该解决的问题。</strong></p><p>LastApply 永远应该小于或等于 committed index！</p><h3 id="leader选举"><a class="anchor" href="#leader选举">#</a> Leader 选举</h3><p>server 开启，初始状态为 follower，并且如果他收到 <code>leader</code> 或者 <code>candidate</code> 的有效 RPCs，那么就会一直维持 follower。如果 follower 在 election timeout 内没有收到任何 RPCs，那么他就会增加 current term 并且成为 candidate 开启选举。</p><h4 id="follower"><a class="anchor" href="#follower">#</a> follower</h4><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226150941941.png" alt="image-20220226150941941"></p><h4 id="candidate"><a class="anchor" href="#candidate">#</a> candidate</h4><p>通过 RequestVote RPC 同时向集群中所有的 server 要求投票。</p><h5 id="requestvote-rpc的结构"><a class="anchor" href="#requestvote-rpc的结构">#</a> RequestVote RPC 的结构：</h5><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226150031701.png" alt="image-20220226150031701"></p><h5 id="candidate需要做的"><a class="anchor" href="#candidate需要做的">#</a> candidate 需要做的：</h5><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226150232338.png" alt="image-20220226150232338"></p><p>这里其实还少些了一个很重要的条件：</p><blockquote><p>Current terms are exchanged whenever servers communicate; if one server’s current term is smaller than the other’s, then it updates its current term to the larger value. If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state. If a server receives a request with a stale term number, it rejects the request.</p></blockquote><p>也就说如果 leader 或者 candidate 发现有人的 current term number 比它的还要大，那么就自动变成 follower，这个特性很重要！</p><h4 id="关于randomized-election-timeouts"><a class="anchor" href="#关于randomized-election-timeouts">#</a> 关于 randomized election timeouts</h4><p>论文中提到：</p><blockquote><p>raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly.</p></blockquote><p>这个一直困恼我，整个随机 election timeouts 是如何解决 split votes。因为有一段话：</p><blockquote><p>This spreads out the servers so that in most cases only a single server will time out; it wins the election and sends heartbeats before any other servers time out.</p></blockquote><p>这段话的意思是说先 timeout 的 server 会获得选举胜利。这里就有一个疑问为什么先 timeout 的 server 一定会获得选举胜利。其实要搞懂还得看 follower。follower 做了一件事：</p><blockquote><p>If a follower receives no communication over a period of time called the election timeout, then it assumes there is no viable leader and begins an election to choose a new leader.</p></blockquote><p>如果 follower 在 <code>election timeout</code> 没有收到 leader 或 candidate 的 rpc，那么它会开启选举，注意这里的超时时间是 <code>election timeout</code> 。也就是说过 leader 挂了的话，那么 <code>election timeout</code> 最小的那个机子就会先意识到，于是他成为 candidate 并且向其他 server 发送 RequestVote RPC。而 raft 的投票机制就是先来先到规则，先发起投票的那个 server 很有可能可以赢得选举。</p><p>candidate 初始化也做了一件事：</p><blockquote><p>Each candidate restarts its randomized election timeout at the start of an<br>election, and it waits for that timeout to elapse before starting the next election</p></blockquote><p>candidate 初始化后也会重新随机初始化这个 <code>election timeout</code> 。如果在这个阶段发生了 split vote 情况，那么 <code>election timeout</code> 最小的 candidate 就会率先超时，并且开启新的投票，于是其他 candidate 看到新的 RequestVote 中的 <code>current term</code> 大于自身的 term number，于是这些 candidate 就会自动变成 followers 并给新的 candidate 投票。于是 splitvote 问题就可以很好地解决了！</p><h3 id="state"><a class="anchor" href="#state">#</a> State</h3><h4 id="所有的server都有的状态"><a class="anchor" href="#所有的server都有的状态">#</a> 所有的 server 都有的状态</h4><p><code>committedIndex</code> ：这就是 logs 中 committed highest log entry index，这个初始化为 0。</p><p><code>log[]</code> ：log 初始化中会把 index 为 0 初始化，也就是后续添加 entry 的 index 都是从 1 开始。</p><p><code>lastApplied</code> ：index of highes log entry applied to state machine。通过 heartbeat 发送了 entry 之后受到了 confirm，确定是 committed 之后就可以执行了。这个 lab 可能不会涉及。</p><p><code>commitIndex</code> ：通过 heartbeat 得到回复，leader 就可以确认 committed 了。</p><h4 id="leader-维护的状态"><a class="anchor" href="#leader-维护的状态">#</a> leader 维护的状态</h4><p><code>matchIndex[]</code> ：对于每个 server，需要复制的最高 log entry index，初始化为 0。我还没搞懂这个最高需要被复制为啥要初始化为 0。</p><p><code>nextIndex[]</code> : leader 会保存下一个为 server 发送了 log entry 的 index。这里的 index 我直接设定为 log 的索引。（初始化为 <code>len(logs)</code> ）</p><h3 id="关于54-safety"><a class="anchor" href="#关于54-safety">#</a> 关于 5.4 Safety</h3><p>有个大前提：leader 可以无限 append log，但是它不能通过选举然后增大自己的 term。</p><h4 id="严格选举"><a class="anchor" href="#严格选举">#</a> 严格选举</h4><p>Raft 保证新选举出来的 leader 必须拥有之前 term 所有的 committed entries，也就是说 log entries 只能通过 leader 流向 follower 而不能从 follower 流向 leader。</p><p>这里 candidate 赢得选举的条件有所不同。</p><p>candidate 在请求投票时，会发送自己的 last log entry 和 follower 的 last log entry 进行对比。如果 candidate last log 的 term 要大，获得 term 相同时 candidate log entry 的 index 要大，则认为 candidate 是优先的，这时候才能进行投票。</p><h4 id="committed规则"><a class="anchor" href="#committed规则">#</a> committed 规则</h4><p>论文的 figure 8 给出了这样一个情况：</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220228215916592.png" alt="image-20220228215916592"></p><p>在 <code>c</code> 情况下， <code>s1</code> 作为 leader 将 index 2 复制给了 s2、s3。然后问题来了，这样 index 2 就是一个 committed entry 了，但是如果 s1 这时候挂掉，s5 参与到选举，由于 s5 在 term3 时候赢得了选举，所以他有 term3 的 log entry，那么 s5 在 <code>d</code> 情况可以赢得 term5 选举，并把 index 2 复制给了其他 server。可以看到此时的 index 2 的 term 变成了 3。之前的 committed 被覆盖了！</p><p>于是 raft 规定，只有当前 term 的 log entries 才能通过计算 replicas 数的方式进行 <code>committed</code> 。</p><p>这里又会有新的问题出现了！如果一个 command 对应了 log entries 是之前的 term，那么及时当前 leader 收到了 majority 的 confirm，那么 leader 也不能 apply 这个 log entry。一直到当前的 term 下来了 new command。那么这个旧 term 下的 log entry 才会得到 confirm。</p><h4 id="safety-argument"><a class="anchor" href="#safety-argument">#</a> Safety argument</h4><p><strong>针对 figure 9 的情况</strong></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220228224051518.png" alt="image-20220228224051518"></p><p>我对于这张图的理解</p><p>如果 s5 可以获得大部分选票的话，那么至少会出现 s3 这种既收到了之前 leader 的 log entry。请注意，论文描述严格选举有一个前提，那就是：赢得选举的 server 必须要在 majority 中保证 up-to-date log entry。这意味着 leader 如果自己任期内的 committed entry 一直是 up-to-date。也就是说 s5 不可能通过选举！</p><p>有一说一，还是有的抽象。。。。</p><h4 id="timing-and-availability"><a class="anchor" href="#timing-and-availability">#</a> Timing and availability</h4><p>需要保证</p><p><strong>broadcastTime≪electionTimeout≪MTBF</strong></p><p><code>broadcastTime</code> 就是平行发送 RPCs 的平均发送时间 + 接受响应时间。</p><p><code>electionTimeout</code> ：这个就是之前提到了选举超时。</p><p><code>MTBF</code> ：the average time between failures for a single server</p><p><strong>MTBFs are several months or more</strong>，所以这个不等式很容易满足</p><h3 id="log-compaction"><a class="anchor" href="#log-compaction">#</a> Log compaction</h3><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220301092739411.png" alt="image-20220301092739411"></p><p>raft 的 snap 机制用于压缩日志，其实它也很简单。</p><p><code>last included index</code> 就是 the last entry the state machine had applied，就是 last apply index，注意，只有 committed 的 entry 才会被 apply，而 raft 可以确保所有 committed entry 都会在 state machine 得到 apply。</p><p>** 并且这个 snapshot 还包含 state machine state！** 这是创建 snap 的最大开销。</p><p>所以之前已经 apply 的 log entry 实际上已经没啥太大帮助了，我们只需要保存 last 用于 AppendEntries consistency check。</p><p>对于特殊情况，比如 leader 现在需要废弃 log entries，但是这些 log entries 中还有一些没有发送给某个 follower，比如 follower server 执行很慢，这个 server 刚刚加入网络。。。</p><p>于是这是 leader 会调用 InstallSnapShot RPC：</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220301095816047.png" alt="image-20220301095816047"></p><p>leader 通过发送 chunk 方式，把 snapshot 发送给 follower。</p><p>如果 follower 的 last log entry 比接收到的 snapshot 里的 last index 还要 stale，那么 follower 就把全部 log entrie 给扔了。如果 follower pre index 和 snap 里的 last index 重合，那么就只丢弃之前的。</p><p>snapshot 的创建规则：</p><ol><li>固定 log size 触发创建 snapshot。</li><li>copy-on-write 技术用于创建。</li></ol><h3 id="听讲"><a class="anchor" href="#听讲">#</a> 听讲</h3><p>使用 condition</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226202117673.png" alt="image-20220226202117673"></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226202457559.png" alt="image-20220226202457559"></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226210149391.png" alt="image-20220226210149391"></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220226210527368.png" alt="image-20220226210527368"></p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220227155319505.png" alt="image-20220227155319505"></p><p>这张图很好地解答了我的疑惑，raft 中的 server 只能是 leader 来对外提供服务，从 client 发送请求到 leader 响应过程分为：</p><ul><li>client 向 server 发送请求，发送给 follower 的请求会被 follower 转发给 leader。</li><li>leader 把 client command 写在 log 中，并通过 Append Entites RPC 发送给其他 followers。</li><li>followers 返回确认消息，如果集群中 majority 都响应了，也就是说 leader 知道了 cluster 中大部分节点就收到了这些 log entity，那么对应的 entity 就是 <code>committed</code> 。</li><li>leader 确认 entity 是 committed 之后，就会开始执行 entity 对应的 command，并把执行这个 command 再次发送给 followers。</li><li>followers 收到确认执行 request 之后开始执行。</li></ul><p>我之前想到的 split partition 问题就可以很好解决了，如果集群分裂为两个 partition，然后各自都有 leader，那么对于 min partition 来说，leader 收不到 majority 的确认，因此 leader 没法执行指令。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220301110023351.png" alt="image-20220301110023351"></p><p>raft 使用 fast backup 方法。</p><h3 id="线性一致性"><a class="anchor" href="#线性一致性">#</a> 线性一致性</h3><h4 id="什么是线性一致性"><a class="anchor" href="#什么是线性一致性">#</a> <strong>什么是线性一致性？</strong></h4><p>Raft 里提到的线性一致性：</p><p><strong>Linearizable semantics</strong> （Linearizability）(each operation appears to execute instantaneously, exactly once, at some point between its invocation and its response)</p><ul><li><p>在一个线性一致性的系统里面，任何操作都可能在调用或者返回之间原子和瞬间执行</p></li><li><p>线性一致性，Linearizability，也称为原子一致性（atomic consistency），强一致性（strong consistency）等</p></li><li><p>也就是通常所说的 CAP 理论中的 C</p></li></ul><p>实现线性一致性需要满足三点：</p><ul><li>瞬间完成（原子性）</li><li>发生在 Inv 和 Resp 两个事件之间</li><li>反映出 “最新” 的值</li></ul><p>1 和 2 很好理解，但 “最新” 怎么理解呢？其实很简单就看写操作：<br><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220301144626139.png" alt="image-20220301144626139"></p><p>在图中，x 的值被写操作划分为 3 个区域，每个区域内对应最新的值，也就是说 “最新” 并不代表<strong>确定</strong>！</p><h4 id="教授讲的线性一致性"><a class="anchor" href="#教授讲的线性一致性">#</a> 教授讲的线性一致性</h4><p>我觉得教授讲的更加言简意赅：</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturesimage-20220316100700951.png" alt="image-20220316100700951"></p><p>如果执行历史是线性的，那么存在操作序列，满足<strong>执行顺序和真实时间相匹配</strong>，<strong>每个读操作一定看到了最新写操作结果</strong>。</p><p>我们以下面这张图为例子：</p><p><strong>执行顺序和真实时间相匹配</strong>：对于非并发也就是时间上不重合的请求，比如 w1 和 w2。这两个请求在时间上不重合所以一定是 w2 发生在 w1 之前。但是对于并发也就是时间上有重合的请求，则需要 <code>each operation appears to execute instantaneously</code> 。</p><p><strong>每个读操作一定看到了最新写操作结果</strong>：这句话的意思就是 R 一定发生在 W 之后，比如读 R1 一定发生在 W1 之后，假如没有最新的 W 操作，那么之后所有读操作一定都是返回 1 的。</p><p><img data-src="https://image-2021-wu.oss-cn-beijing.aliyuncs.com/blogs/picturespicturespicturesimage-20220301122149285.png" alt="image-20220301122149285"></p><h3 id="遇到的问题"><a class="anchor" href="#遇到的问题">#</a> 遇到的问题</h3><h4 id="227日更新"><a class="anchor" href="#227日更新">#</a> 2.27 日更新：</h4><p>成功完成了 Lab2A，但是还遗留了一个问题，那就是为什么限制选举执行时间才能通过 test，按道理只要选举超时之后，之前选举的结果就会被废弃的。。。</p><pre><code>Test (2A): initial election ...
labgob warning: Decoding into a non-default variable/field Term may not work
  ... Passed --   3.0  3   56    6872    0
Test (2A): election after network failure ...
  ... Passed --   9.2  3  238   17813    0
Test (2A): multiple elections ...
  ... Passed --   6.5  7  642   55493    0
PASS
ok  	6.824/raft	18.733s

</code></pre><h4 id="31号更新"><a class="anchor" href="#31号更新">#</a> 3.1 号更新</h4><p>raft 在 leader 当选之后会立即在 leader 的 log 中生成一条 no-hup 日志并通过 heartbeat 传递给其他 server。但是在 MIT6.824 实验中没办法实现 no-hup。</p><h4 id="34-更新"><a class="anchor" href="#34-更新">#</a> 3.4 更新</h4><p>愉快通关！</p><div class="tags"><a href="/tags/MIT6-824/" rel="tag"><i class="ic i-tag"></i> MIT6.824</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-05-11 19:42:45" itemprop="dateModified" datetime="2022-05-11T19:42:45+08:00">2022-05-11</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Kalice 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Kalice 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Kalice <i class="ic i-at"><em>@</em></i>Life</li><li class="link"><strong>本文链接：</strong> <a href="https://songlinlife.top/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab2-Raft/" title="MIT6.824: lab2 Raft">https://songlinlife.top/2022/分布式/MIT6-824-lab2-Raft/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/xlab/Artur-%E8%B0%83%E5%BA%A6%E5%99%A8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicivghyooj20zk0m8dir.jpg" title="Artur: 调度器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> xlab</span><h3>Artur: 调度器</h3></a></div><div class="item right"><a href="/2022/xlab/grimoireLab-%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciundwu5j20zk0m8n9e.jpg" title="grimoireLab: 数据增强相关组件"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> xlab</span><h3>grimoireLab: 数据增强相关组件</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2a"><span class="toc-number">1.</span> <span class="toc-text">Part 2A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part2b"><span class="toc-number">2.</span> <span class="toc-text">Part2B</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E6%9B%B4%E6%96%B0"><span class="toc-number">2.1.</span> <span class="toc-text">3.3 更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2c"><span class="toc-number">3.</span> <span class="toc-text">Part 2C</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E6%9B%B4%E6%96%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">3.3 更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#testfigure8unreliable2c%E6%8A%A5%E9%94%99%E8%BF%94%E5%9B%9Etrue%E7%9A%84appendentriesrpc%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">TestFigure8Unreliable2C 报错，返回 true 的 AppendEntriesRPC 丢失问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unreliable-churn-out-of-range-%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">unreliable churn out of range 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#testfigure8unreliable2c%E7%A8%80%E6%9C%89out-of-range"><span class="toc-number">3.1.3.</span> <span class="toc-text">TestFigure8Unreliable2C 稀有 out of range</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part2d"><span class="toc-number">4.</span> <span class="toc-text">Part2D</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E4%BC%A4%E9%80%9A%E5%85%B334%E6%9B%B4%E6%96%B0"><span class="toc-number">4.1.</span> <span class="toc-text">无伤通关！！！！！（3.4 更新）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#installsnapshot-rpc"><span class="toc-number">4.2.</span> <span class="toc-text">Installsnapshot RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">遗留的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raft-basic"><span class="toc-number">6.</span> <span class="toc-text">Raft Basic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leader%E9%80%89%E4%B8%BE"><span class="toc-number">7.</span> <span class="toc-text">Leader 选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#follower"><span class="toc-number">7.1.</span> <span class="toc-text">follower</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#candidate"><span class="toc-number">7.2.</span> <span class="toc-text">candidate</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#requestvote-rpc%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">RequestVote RPC 的结构：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#candidate%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84"><span class="toc-number">7.2.2.</span> <span class="toc-text">candidate 需要做的：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Erandomized-election-timeouts"><span class="toc-number">7.3.</span> <span class="toc-text">关于 randomized election timeouts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state"><span class="toc-number">8.</span> <span class="toc-text">State</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%9A%84server%E9%83%BD%E6%9C%89%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">所有的 server 都有的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#leader-%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">8.2.</span> <span class="toc-text">leader 维护的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E54-safety"><span class="toc-number">9.</span> <span class="toc-text">关于 5.4 Safety</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E9%80%89%E4%B8%BE"><span class="toc-number">9.1.</span> <span class="toc-text">严格选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#committed%E8%A7%84%E5%88%99"><span class="toc-number">9.2.</span> <span class="toc-text">committed 规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#safety-argument"><span class="toc-number">9.3.</span> <span class="toc-text">Safety argument</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timing-and-availability"><span class="toc-number">9.4.</span> <span class="toc-text">Timing and availability</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log-compaction"><span class="toc-number">10.</span> <span class="toc-text">Log compaction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AC%E8%AE%B2"><span class="toc-number">11.</span> <span class="toc-text">听讲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.</span> <span class="toc-text">线性一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.1.</span> <span class="toc-text">什么是线性一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%99%E6%8E%88%E8%AE%B2%E7%9A%84%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.2.</span> <span class="toc-text">教授讲的线性一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.</span> <span class="toc-text">遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#227%E6%97%A5%E6%9B%B4%E6%96%B0"><span class="toc-number">13.1.</span> <span class="toc-text">2.27 日更新：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E5%8F%B7%E6%9B%B4%E6%96%B0"><span class="toc-number">13.2.</span> <span class="toc-text">3.1 号更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E6%9B%B4%E6%96%B0"><span class="toc-number">13.3.</span> <span class="toc-text">3.4 更新</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-mapreduce/" rel="bookmark" title="MIT6.824: mapreduce">MIT6.824: mapreduce</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-GFS/" rel="bookmark" title="MIT6.824: GFS">MIT6.824: GFS</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-The-Design-of-a-Practical-System-for-Fault-Tolerant-Virtual-Machines/" rel="bookmark" title="MIT6.824: The Design of a Practical System for Fault-Tolerant Virtual Machines">MIT6.824: The Design of a Practical System for Fault-Tolerant Virtual Machines</a></li><li class="active"><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab2-Raft/" rel="bookmark" title="MIT6.824: lab2 Raft">MIT6.824: lab2 Raft</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-zookeeper/" rel="bookmark" title="MIT6.824: ZooKeeper: Wait-free coordination for Internet-scale systems">MIT6.824: ZooKeeper: Wait-free coordination for Internet-scale systems</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-Object-Storage-on-CRAQ-High-throughput-chain-replication-for-read-mostly-workloads/" rel="bookmark" title="MIT6.824: Object Storage on CRAQ High-throughput chain replication for read-mostly workloads">MIT6.824: Object Storage on CRAQ High-throughput chain replication for read-mostly workloads</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab3-KV-Service/" rel="bookmark" title="MIT6.824: lab3 KV Service">MIT6.824: lab3 KV Service</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-Aurora/" rel="bookmark" title="MIT6.824: Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases">MIT6.824: Amazon Aurora: Design Considerations for High Throughput Cloud-Native Relational Databases</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824%EF%BC%9AFrangipani-A-Scalable-Distributed-File-System/" rel="bookmark" title="MIT6.824：Frangipani: A Scalable Distributed File System">MIT6.824：Frangipani: A Scalable Distributed File System</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="bookmark" title="MIT6.824：分布式事务">MIT6.824：分布式事务</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824%EF%BC%9ASpaner/" rel="bookmark" title="MIT6.824：Spaner">MIT6.824：Spaner</a></li><li><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-Lab4/" rel="bookmark" title="MIT6.824:Lab4">MIT6.824:Lab4</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Kalice" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Kalice</p><div class="description" itemprop="description">Life is not about lifestyle, it means Lithium and Ferrum.</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">109</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">42</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/xlab/Artur-%E8%B0%83%E5%BA%A6%E5%99%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/xlab/grimoireLab-%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2022/Go/Golang-cookies%E4%B8%8Esessions/" title="Golang: cookies与sessions">Golang: cookies与sessions</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a></div><span><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-lab3-KV-Service/" title="MIT6.824: lab3 KV Service">MIT6.824: lab3 KV Service</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2022/Go/golang-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/" title="golang 并发学习">golang 并发学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2022/Go/golang-Web%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" title="golang Web相关学习">golang Web相关学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ss/" title="分类于 琐事">琐事</a></div><span><a href="/2022/ss/Git-%E4%BB%A3%E7%90%86/" title="Git 代理">Git 代理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/python/" title="分类于 Python">Python</a></div><span><a href="/2021/python/pip%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" title="pip 相关问题">pip 相关问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ss/" title="分类于 琐事">琐事</a></div><span><a href="/2022/PPT%E5%AD%A6%E4%B9%A0/" title="PPT学习">PPT学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Go/" title="分类于 Go">Go</a></div><span><a href="/2022/Go/Golang%EF%BC%9A%E6%9F%A5%E8%AF%A2MongoDB/" title="Golang：查询MongoDB">Golang：查询MongoDB</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 AI">AI</a></div><span><a href="/2021/DGL-01-%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E8%8C%83%E5%BC%8F/" title="DGL(01): 信息传递范式">DGL(01): 信息传递范式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a></div><span><a href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-824-Object-Storage-on-CRAQ-High-throughput-chain-replication-for-read-mostly-workloads/" title="MIT6.824: Object Storage on CRAQ High-throughput chain replication for read-mostly workloads">MIT6.824: Object Storage on CRAQ High-throughput chain replication for read-mostly workloads</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Kalice @ Songlin</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">234k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:32</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/分布式/MIT6-824-lab2-Raft/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,mermaid:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->